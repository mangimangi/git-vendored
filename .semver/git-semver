#!/usr/bin/env python3
"""git-semver — config-driven semantic versioning for git repos.

Subcommands:
    version                          Print current version
    check [--since <commit>]         Check if a bump is needed (exit 0=yes, 1=no)
    bump [patch|minor|major] [opts]  Bump version, commit, tag, push

Config: .semver/config.json (see README for schema)
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime, timezone
from fnmatch import fnmatch
from pathlib import Path

DEFAULT_CONFIG_PATH = ".semver/config.json"
DEFAULT_VERSION_FILE = "VERSION"


# ── Config ──────────────────────────────────────────────────────────────────

def load_config(config_path=None):
    """Load and validate .semver/config.json."""
    path = Path(config_path or DEFAULT_CONFIG_PATH)
    if not path.exists():
        print(f"Error: config not found: {path}", file=sys.stderr)
        sys.exit(1)
    with open(path) as f:
        config = json.load(f)
    if "files" not in config:
        print("Error: 'files' key required in config", file=sys.stderr)
        sys.exit(1)
    if "updates" not in config:
        print("Error: 'updates' key required in config", file=sys.stderr)
        sys.exit(1)
    return config


def get_version_file(config):
    """Return the version_file path from config (default: VERSION)."""
    return config.get("version_file", DEFAULT_VERSION_FILE)


def parse_changelog_config(config):
    """Parse changelog config into (enabled, file, ignore_prefixes).

    Returns:
        (enabled: bool, file: str, ignore_prefixes: list[str])
    """
    cl = config.get("changelog", True)
    if cl is False:
        return False, None, []
    if cl is True or cl is None:
        return True, "CHANGELOG.md", []
    # Object form
    return (
        True,
        cl.get("file", "CHANGELOG.md"),
        cl.get("ignore_prefixes", []),
    )


# ── Version ─────────────────────────────────────────────────────────────────

def read_version(version_file):
    """Read current version from version_file."""
    path = Path(version_file)
    if not path.exists():
        print(f"Error: version file not found: {path}", file=sys.stderr)
        sys.exit(1)
    return path.read_text().strip()


def parse_version(version_str):
    """Parse 'X.Y.Z' into (major, minor, patch) ints."""
    parts = version_str.split(".")
    if len(parts) != 3:
        print(f"Error: invalid version format: {version_str}", file=sys.stderr)
        sys.exit(1)
    return int(parts[0]), int(parts[1]), int(parts[2])


def compute_new_version(major, minor, patch, bump_type):
    """Compute the new version tuple given a bump type."""
    if bump_type == "major":
        return major + 1, 0, 0
    elif bump_type == "minor":
        return major, minor + 1, 0
    else:
        return major, minor, patch + 1


def format_version(major, minor, patch):
    """Format version tuple as string."""
    return f"{major}.{minor}.{patch}"


# ── File pattern matching ───────────────────────────────────────────────────

def matches_pattern(filepath, pattern):
    """Check if filepath matches a glob pattern using fnmatch semantics.

    Supports *, **, and ? patterns. Single * does not match across /.
    """
    if "**" in pattern:
        # Split on ** and match segments
        parts = pattern.split("**")
        if len(parts) == 2:
            prefix, suffix = parts
            prefix = prefix.rstrip("/")
            suffix = suffix.lstrip("/")
            if prefix and not filepath.startswith(prefix + "/") and filepath != prefix:
                return False
            if suffix:
                if prefix:
                    remaining = filepath[len(prefix):].lstrip("/")
                else:
                    remaining = filepath
                # Match suffix against the filename or any trailing path segment
                return fnmatch(remaining, suffix) or fnmatch(
                    remaining.split("/")[-1] if "/" in remaining else remaining,
                    suffix,
                )
            return True
    # For patterns without **, use path-aware matching:
    # Split both by / and match segment by segment
    if "/" in pattern:
        pat_parts = pattern.split("/")
        file_parts = filepath.split("/")
        if len(pat_parts) != len(file_parts):
            return False
        return all(fnmatch(fp, pp) for fp, pp in zip(file_parts, pat_parts))
    # Simple pattern (no /) — only matches top-level files
    # (single * must not match across /)
    if "/" in filepath:
        return False
    return fnmatch(filepath, pattern)


def check_files_changed(changed_files, patterns):
    """Check if any changed file matches any pattern.

    Returns list of (file, pattern) matches, or empty list.
    """
    matches = []
    for filepath in changed_files:
        for pattern in patterns:
            if matches_pattern(filepath, pattern):
                matches.append((filepath, pattern))
                break  # One match per file is enough
    return matches


# ── Git helpers ─────────────────────────────────────────────────────────────

def git(*args, check=True, capture=True):
    """Run a git command and return stdout."""
    cmd = ["git"] + list(args)
    result = subprocess.run(
        cmd,
        capture_output=capture,
        text=True,
        check=False,
    )
    if check and result.returncode != 0:
        stderr = result.stderr.strip() if capture else ""
        print(f"Error: git {' '.join(args)} failed: {stderr}", file=sys.stderr)
        sys.exit(1)
    return result


def get_changed_files(since):
    """Get list of files changed since the given commit."""
    if since == "0" * 40:
        # Initial commit — diff the tree
        result = git("diff-tree", "--no-commit-id", "--name-only", "-r", "HEAD")
    else:
        result = git("diff", "--name-only", since, "HEAD")
    return [f for f in result.stdout.strip().split("\n") if f]


def get_commits_since_tag(tag=None):
    """Get commit messages since the last tag (or all if no tag)."""
    if tag is None:
        result = git(
            "describe", "--tags", "--abbrev=0", "--match", "v*",
            check=False,
        )
        tag = result.stdout.strip() if result.returncode == 0 else None

    if tag:
        result = git(
            "log", f"{tag}..HEAD", "--no-merges", "--pretty=format:%s",
        )
    else:
        result = git("log", "--no-merges", "--pretty=format:%s")
    return [line for line in result.stdout.strip().split("\n") if line]


# ── File updates ────────────────────────────────────────────────────────────

def apply_updates(updates, new_version):
    """Apply version updates to configured files."""
    for filepath, action in updates.items():
        path = Path(filepath)
        if not path.exists():
            print(f"Warning: {filepath} not found, skipping")
            continue
        if action == "file":
            path.write_text(new_version + "\n")
            print(f"Updated {filepath} (file)")
        elif isinstance(action, list):
            content = path.read_text()
            for pattern in action:
                if "=" in pattern:
                    # Backreference \1 ensures matching open/close quote is preserved
                    regex = re.escape(pattern) + r"""(["\']?)\d+\.\d+\.\d+\1"""

                    def _repl(m, _pat=pattern, _ver=new_version):
                        q = m.group(1)
                        return _pat + q + _ver + q

                    content = re.sub(regex, _repl, content)
                else:
                    regex = re.escape(pattern) + r"\d+\.\d+\.\d+"
                    replacement = pattern + new_version
                    content = re.sub(regex, replacement, content)
            path.write_text(content)
            print(f"Updated {filepath} (patterns)")


# ── Changelog ───────────────────────────────────────────────────────────────

def update_changelog(changelog_file, new_version, description=None, ignore_prefixes=None):
    """Update changelog with a new version entry."""
    path = Path(changelog_file)
    if not path.exists():
        print(f"Warning: {changelog_file} not found, skipping changelog")
        return

    if description:
        commits_text = f"- {description}"
    else:
        commits = get_commits_since_tag()
        if ignore_prefixes:
            commits = [
                c for c in commits
                if not any(c.startswith(p) for p in ignore_prefixes)
            ]
        commits_text = "\n".join(f"- {c}" for c in commits) if commits else "- No notable changes"

    date = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    entry = f"## [{new_version}] - {date}\n\n### Changed\n{commits_text}\n\n"

    content = path.read_text()
    idx = content.find("\n## [")
    if idx >= 0:
        content = content[: idx + 1] + entry + content[idx + 1 :]
    else:
        content += "\n" + entry
    path.write_text(content)
    print(f"Updated {changelog_file}")


# ── Subcommands ─────────────────────────────────────────────────────────────

def cmd_version(args):
    """Print current version."""
    config = load_config(args.config)
    version_file = get_version_file(config)
    version = read_version(version_file)
    print(version)


def cmd_check(args):
    """Check if a version bump is needed based on changed files."""
    config = load_config(args.config)
    patterns = config["files"]
    since = args.since or "HEAD~1"

    changed = get_changed_files(since)
    if not changed:
        print("No files changed")
        sys.exit(1)

    matches = check_files_changed(changed, patterns)
    if matches:
        for filepath, pattern in matches:
            print(f"Matched: {filepath} (pattern: {pattern})")
        sys.exit(0)
    else:
        print("No matching files changed")
        sys.exit(1)


def cmd_bump(args):
    """Bump version, update files, commit, tag, push."""
    config = load_config(args.config)
    version_file = get_version_file(config)
    bump_type = args.bump_type or "patch"

    # Read and bump version
    current = read_version(version_file)
    major, minor, patch = parse_version(current)
    new_major, new_minor, new_patch = compute_new_version(major, minor, patch, bump_type)
    new_version = format_version(new_major, new_minor, new_patch)
    print(f"Bumping ({bump_type}): {current} -> {new_version}")

    # Write version file
    Path(version_file).write_text(new_version + "\n")
    print(f"Updated {version_file}")

    # Apply updates
    apply_updates(config.get("updates", {}), new_version)

    # Update changelog
    cl_enabled, cl_file, cl_ignore = parse_changelog_config(config)
    if cl_enabled:
        update_changelog(cl_file, new_version, args.description, cl_ignore)

    if args.no_commit:
        print(f"\nVersion bumped to {new_version} (files only, no commit)")
        return

    # Commit
    git("add", "-A")
    git("commit", "-m", f"chore: bump version to v{new_version}")
    print(f"Committed: chore: bump version to v{new_version}")

    # Tag
    git("tag", "-a", f"v{new_version}", "-m", f"v{new_version}")
    git("tag", "-f", "latest")
    print(f"Tagged: v{new_version} + latest")

    if args.no_push:
        print(f"\nVersion bumped to {new_version} (no push)")
        return

    # Push
    git("push", check=True)
    git("push", "--tags", "--force", check=True)
    print(f"\nVersion bumped to {new_version} and pushed")


# ── CLI ─────────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(
        description="Config-driven semantic versioning for git repos",
        prog="git-semver",
    )
    parser.add_argument(
        "--config", default=None,
        help=f"Config file path (default: {DEFAULT_CONFIG_PATH})",
    )
    subparsers = parser.add_subparsers(dest="command")

    # version
    subparsers.add_parser("version", help="Print current version")

    # check
    check_parser = subparsers.add_parser("check", help="Check if bump is needed")
    check_parser.add_argument("--since", default=None, help="Commit ref to diff since")

    # bump
    bump_parser = subparsers.add_parser("bump", help="Bump version")
    bump_parser.add_argument(
        "bump_type", nargs="?", default="patch",
        choices=["patch", "minor", "major"],
        help="Bump type (default: patch)",
    )
    bump_parser.add_argument("--description", default=None, help="Changelog description override")
    bump_parser.add_argument("--no-push", action="store_true", help="Skip push")
    bump_parser.add_argument("--no-commit", action="store_true", help="Skip commit and push")

    args = parser.parse_args()
    if not args.command:
        parser.print_help()
        sys.exit(1)

    commands = {
        "version": cmd_version,
        "check": cmd_check,
        "bump": cmd_bump,
    }
    commands[args.command](args)


if __name__ == "__main__":
    main()
