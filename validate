#!/usr/bin/env python3
"""Validate whether a repo implements the git-vendored vendor contract.

Standalone validation tool — does not install the vendor, just checks contract
compliance. Eight checks covering the full v2 vendor contract.

Usage:
    python3 validate <owner/repo> [--version <version>]

Environment:
    GH_TOKEN / GITHUB_TOKEN - Auth token for GitHub API access
"""

import argparse
import base64
import os
import subprocess
import sys
import tempfile


# ── Auth ─────────────────────────────────────────────────────────────────

def get_auth_token():
    """Resolve auth token from environment (GH_TOKEN, then GITHUB_TOKEN)."""
    return os.environ.get("GH_TOKEN") or os.environ.get("GITHUB_TOKEN")


def _gh_env(token):
    """Build environment dict with GH_TOKEN set."""
    env = os.environ.copy()
    if token:
        env["GH_TOKEN"] = token
    return env


# ── Validation result collector ──────────────────────────────────────────

class ValidationResult:
    """Collects pass/fail results for validation checks."""

    def __init__(self):
        self.checks = []

    def passed(self, name, detail=None):
        msg = f"  [PASS] {name}"
        if detail:
            msg += f" ({detail})"
        self.checks.append(("PASS", msg))
        print(msg)

    def failed(self, name, detail=None):
        msg = f"  [FAIL] {name}"
        if detail:
            msg += f" -- {detail}"
        self.checks.append(("FAIL", msg))
        print(msg)

    @property
    def pass_count(self):
        return sum(1 for status, _ in self.checks if status == "PASS")

    @property
    def fail_count(self):
        return sum(1 for status, _ in self.checks if status == "FAIL")

    @property
    def total(self):
        return len(self.checks)

    @property
    def all_passed(self):
        return self.fail_count == 0

    def summary(self):
        if self.all_passed:
            return f"Result: PASS ({self.pass_count}/{self.total} checks passed)"
        return f"Result: FAIL ({self.fail_count}/{self.total} checks failed)"


# ── Fail-fast checks (1-3) ──────────────────────────────────────────────

def check_repo_exists(repo, token, result):
    """Check 1: Repo exists and is accessible."""
    env = _gh_env(token)
    proc = subprocess.run(
        ["gh", "api", f"repos/{repo}", "--jq", ".full_name"],
        capture_output=True, text=True, env=env
    )
    if proc.returncode != 0:
        result.failed("Repo exists", f"cannot access {repo}")
        return False
    result.passed("Repo exists")
    return True


def check_install_sh_exists(repo, token, result):
    """Check 2: install.sh exists at repo root."""
    env = _gh_env(token)
    proc = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/install.sh", "--jq", ".name"],
        capture_output=True, text=True, env=env
    )
    if proc.returncode != 0 or not proc.stdout.strip():
        result.failed("install.sh exists", f"no install.sh at root of {repo}")
        return False
    result.passed("install.sh exists")
    return True


def check_version_resolvable(repo, token, requested_version, result):
    """Check 3: Version is resolvable. Returns resolved version or None."""
    if requested_version and requested_version != "latest":
        result.passed("Version resolvable", requested_version)
        return requested_version

    env = _gh_env(token)

    # Try releases API first
    proc = subprocess.run(
        ["gh", "api", f"repos/{repo}/releases/latest", "--jq", ".tag_name"],
        capture_output=True, text=True, env=env
    )
    if proc.returncode == 0 and proc.stdout.strip():
        version = proc.stdout.strip().lstrip("v")
        result.passed("Version resolvable", version)
        return version

    # Fallback to VERSION file
    proc = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/VERSION", "--jq", ".content"],
        capture_output=True, text=True, env=env
    )
    if proc.returncode == 0 and proc.stdout.strip():
        try:
            version = base64.b64decode(proc.stdout.strip()).decode().strip()
            result.passed("Version resolvable", version)
            return version
        except Exception:
            pass

    result.failed("Version resolvable", "no releases or VERSION file found")
    return None


# ── Collect-and-report checks (4-8) ─────────────────────────────────────

def download_install_sh(repo, version, token):
    """Download install.sh content from the repo at the given version."""
    env = _gh_env(token)
    ref = f"v{version}"
    proc = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/install.sh?ref={ref}",
         "--jq", ".content"],
        capture_output=True, text=True, env=env
    )
    if proc.returncode != 0 or not proc.stdout.strip():
        # Retry without v prefix
        proc = subprocess.run(
            ["gh", "api", f"repos/{repo}/contents/install.sh?ref={version}",
             "--jq", ".content"],
            capture_output=True, text=True, env=env
        )
    if proc.returncode == 0 and proc.stdout.strip():
        try:
            return base64.b64decode(proc.stdout.strip()).decode()
        except Exception:
            return None
    return None


def check_valid_shebang(script_content, result):
    """Check 4: Valid shebang line."""
    if script_content is None:
        result.failed("Valid shebang", "could not download install.sh")
        return False
    first_line = script_content.split("\n", 1)[0].strip()
    valid_shebangs = ["#!/bin/bash", "#!/usr/bin/env bash"]
    if first_line in valid_shebangs:
        result.passed("Valid shebang", first_line)
        return True
    result.failed("Valid shebang", f"got: {first_line}")
    return False


def check_syntax_valid(script_content, result):
    """Check 5: bash -n syntax check."""
    if script_content is None:
        result.failed("Syntax valid", "could not download install.sh")
        return False
    with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
        f.write(script_content)
        f.flush()
        tmp_path = f.name
    try:
        proc = subprocess.run(
            ["bash", "-n", tmp_path],
            capture_output=True, text=True
        )
        if proc.returncode == 0:
            result.passed("Syntax valid", "bash -n passed")
            return True
        result.failed("Syntax valid", proc.stderr.strip() or "bash -n failed")
        return False
    finally:
        os.unlink(tmp_path)


def run_dryrun_install(repo, version, script_content, token, result):
    """Checks 6-8: Dry-run install in sandbox, manifest written, files exist."""
    if script_content is None:
        result.failed("Dry-run install", "could not download install.sh")
        result.failed("Manifest written", "skipped (no install.sh)")
        result.failed("Manifest files exist", "skipped (no manifest)")
        return

    sandbox = tempfile.mkdtemp(prefix="gv-validate-")
    try:
        # Set up sandbox paths
        vendor_name = repo.split("/")[-1] if "/" in repo else repo
        install_dir = os.path.join(".vendored", "pkg", vendor_name)
        manifest_file = os.path.join(sandbox, "manifest.files")
        script_path = os.path.join(sandbox, "install.sh")

        # Write install.sh to sandbox
        with open(script_path, "w") as f:
            f.write(script_content)
        os.chmod(script_path, 0o755)

        # Create install dir
        abs_install_dir = os.path.join(sandbox, install_dir)
        os.makedirs(abs_install_dir, exist_ok=True)

        # Build environment
        env = _gh_env(token)
        env["VENDOR_REPO"] = repo
        env["VENDOR_REF"] = f"v{version}"
        env["VENDOR_MANIFEST"] = manifest_file
        env["VENDOR_INSTALL_DIR"] = install_dir

        # Check 6: Dry-run succeeds
        proc = subprocess.run(
            ["bash", script_path],
            capture_output=True, text=True,
            env=env, cwd=sandbox
        )
        if proc.returncode != 0:
            stderr_snippet = proc.stderr.strip()[:200] if proc.stderr else ""
            detail = f"exit code {proc.returncode}"
            if stderr_snippet:
                detail += f": {stderr_snippet}"
            result.failed("Dry-run install", detail)
        else:
            result.passed("Dry-run install", "exit code 0")

        # Check 7: Manifest written
        if not os.path.isfile(manifest_file):
            result.failed("Manifest written",
                          "install.sh did not write to $VENDOR_MANIFEST")
            result.failed("Manifest files exist", "skipped (no manifest)")
            return

        with open(manifest_file) as f:
            manifest_lines = [line.strip() for line in f if line.strip()]

        if not manifest_lines:
            result.failed("Manifest written", "manifest file is empty")
            result.failed("Manifest files exist", "skipped (empty manifest)")
            return

        result.passed("Manifest written", f"{len(manifest_lines)} files")

        # Check 8: Manifest files exist on disk
        missing = []
        for path in manifest_lines:
            full_path = os.path.join(sandbox, path)
            if not os.path.exists(full_path):
                missing.append(path)

        if missing:
            detail = f"{len(missing)} missing: {', '.join(missing[:5])}"
            if len(missing) > 5:
                detail += f" (and {len(missing) - 5} more)"
            result.failed("Manifest files exist", detail)
        else:
            result.passed("Manifest files exist",
                          f"all {len(manifest_lines)} files found on disk")

    finally:
        # Clean up sandbox
        import shutil
        shutil.rmtree(sandbox, ignore_errors=True)


# ── Main ─────────────────────────────────────────────────────────────────

def validate(repo, requested_version=None):
    """Run all validation checks against a repo. Returns exit code."""
    token = get_auth_token()
    result = ValidationResult()

    print(f"\nValidating vendor contract: {repo}\n")

    # Fail-fast checks (1-3)
    if not check_repo_exists(repo, token, result):
        print(f"\n{result.summary()}")
        return 1

    if not check_install_sh_exists(repo, token, result):
        print(f"\n{result.summary()}")
        return 1

    version = check_version_resolvable(repo, token, requested_version, result)
    if version is None:
        print(f"\n{result.summary()}")
        return 1

    # Download install.sh for remaining checks
    script_content = download_install_sh(repo, version, token)

    # Collect-and-report checks (4-8)
    check_valid_shebang(script_content, result)
    check_syntax_valid(script_content, result)
    run_dryrun_install(repo, version, script_content, token, result)

    print(f"\n{result.summary()}")
    return 0 if result.all_passed else 1


def main():
    parser = argparse.ArgumentParser(
        description="Validate whether a repo implements the git-vendored "
                    "vendor contract.")
    parser.add_argument("repo", help="GitHub repo to validate (owner/repo)")
    parser.add_argument("--version", default="latest",
                        help="Version to validate against (default: latest)")
    args = parser.parse_args()

    sys.exit(validate(args.repo, args.version))


if __name__ == "__main__":
    main()
