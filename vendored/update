#!/usr/bin/env python3
"""Vendor update script.

Reads .vendored/config.json, resolves the target version for a vendor,
downloads and runs its install.sh, and outputs structured results for
PR creation.

Usage:
    python3 .vendored/update <vendor|all> [--version <version>]

Output (key=value lines for workflow consumption):
    vendor=<name>
    old_version=<version>
    new_version=<version>
    changed=true|false

Environment:
    GITHUB_TOKEN - Auth for public repos
    VENDOR_PAT   - Auth for private repos (vendor.private: true)
"""

import argparse
import json
import os
import subprocess
import sys
import tempfile


def load_config(config_path=".vendored/config.json"):
    """Load and return the vendored config."""
    if not os.path.isfile(config_path):
        print(f"::error::Config not found: {config_path}")
        sys.exit(1)
    with open(config_path) as f:
        return json.load(f)


def get_auth_token(vendor_config):
    """Get the appropriate auth token for a vendor."""
    if vendor_config.get("private"):
        token = os.environ.get("VENDOR_PAT", "")
        if not token:
            print("::error::VENDOR_PAT required for private vendor repos")
            sys.exit(1)
        return token
    return os.environ.get("GITHUB_TOKEN", os.environ.get("GH_TOKEN", ""))


def resolve_version(vendor_name, vendor_config, requested_version, token):
    """Resolve the target version for a vendor.

    Strategy:
    1. If a specific version is given (not 'latest'), use it
    2. Try GitHub releases API for latest release tag
    3. Fall back to reading VERSION file from default branch
    """
    repo = vendor_config["repo"]

    if requested_version and requested_version != "latest":
        return requested_version

    # Try releases API
    version = _resolve_from_releases(repo, token)
    if version:
        return version

    # Fallback: VERSION file on default branch
    version = _resolve_from_version_file(repo, token)
    if version:
        return version

    print(f"::error::Could not resolve version for {vendor_name} from {repo}")
    sys.exit(1)


def _resolve_from_releases(repo, token):
    """Try to get latest version from GitHub releases."""
    env = _gh_env(token)
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/releases/latest", "--jq", ".tag_name"],
        capture_output=True, text=True, env=env
    )
    if result.returncode == 0 and result.stdout.strip():
        tag = result.stdout.strip()
        # Strip leading 'v' if present
        return tag.lstrip("v")
    return None


def _resolve_from_version_file(repo, token):
    """Fallback: read VERSION file from repo default branch."""
    env = _gh_env(token)
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/VERSION", "--jq", ".content"],
        capture_output=True, text=True, env=env
    )
    if result.returncode == 0 and result.stdout.strip():
        import base64
        try:
            content = base64.b64decode(result.stdout.strip()).decode().strip()
            return content
        except Exception:
            pass
    return None


def _gh_env(token):
    """Build environment dict with GH_TOKEN set."""
    env = os.environ.copy()
    if token:
        env["GH_TOKEN"] = token
    return env


def get_current_version(vendor_name, vendor_config):
    """Read the currently installed version for a vendor.

    Checks vendor-specific version file patterns:
    - .<vendor_dir>/.version (e.g., .vendored/.version, .pearls/.prl-version)
    """
    # Common patterns for vendor version files
    candidates = []

    # Check if vendor has a known version file based on config patterns
    for pattern in vendor_config.get("allowed", []):
        if ".version" in pattern or "prl-version" in pattern:
            # This is likely a version file
            # Only use if it's a concrete path (no globs)
            if "*" not in pattern and "?" not in pattern:
                candidates.append(pattern)

    # Also try standard convention: first protected dir + .version
    for pattern in vendor_config.get("protected", []):
        if pattern.endswith("/**"):
            base_dir = pattern[:-3]  # strip /**
            candidates.append(f"{base_dir}/.version")
            break

    for path in candidates:
        if os.path.isfile(path):
            return open(path).read().strip()

    return None


def download_and_run_install(vendor_name, vendor_config, version, token):
    """Download the vendor's install.sh and run it."""
    repo = vendor_config["repo"]
    env = _gh_env(token)

    # Download install.sh at the target version ref
    ref = f"v{version}"
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/install.sh?ref={ref}",
         "--jq", ".content"],
        capture_output=True, text=True, env=env
    )

    if result.returncode != 0 or not result.stdout.strip():
        # Try without v prefix
        result = subprocess.run(
            ["gh", "api", f"repos/{repo}/contents/install.sh?ref={version}",
             "--jq", ".content"],
            capture_output=True, text=True, env=env
        )

    if result.returncode != 0 or not result.stdout.strip():
        print(f"::error::Failed to download install.sh from {repo} at {ref}")
        print(f"  stderr: {result.stderr.strip()}")
        sys.exit(1)

    import base64
    install_script = base64.b64decode(result.stdout.strip()).decode()

    # Write to temp file and execute
    with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
        f.write(install_script)
        temp_path = f.name

    try:
        run_env = env.copy()
        run_env["GH_TOKEN"] = token if token else run_env.get("GH_TOKEN", "")

        result = subprocess.run(
            ["bash", temp_path, version],
            capture_output=True, text=True, env=run_env
        )
        print(result.stdout)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
        if result.returncode != 0:
            print(f"::error::install.sh failed for {vendor_name} (exit {result.returncode})")
            sys.exit(1)
    finally:
        os.unlink(temp_path)


def install_vendor(vendor_name, vendor_config, requested_version):
    """Install or update a single vendor. Returns result dict."""
    token = get_auth_token(vendor_config)
    target_version = resolve_version(vendor_name, vendor_config, requested_version, token)
    current_version = get_current_version(vendor_name, vendor_config)

    if current_version == target_version:
        print(f"{vendor_name}: already at v{target_version}, skipping")
        return {
            "vendor": vendor_name,
            "old_version": current_version or "none",
            "new_version": target_version,
            "changed": False,
        }

    print(f"{vendor_name}: {current_version or 'none'} -> {target_version}")
    download_and_run_install(vendor_name, vendor_config, target_version, token)

    return {
        "vendor": vendor_name,
        "old_version": current_version or "none",
        "new_version": target_version,
        "changed": True,
    }


def write_github_output(pairs):
    """Write key=value pairs to $GITHUB_OUTPUT file if env var is set."""
    output_file = os.environ.get("GITHUB_OUTPUT")
    if not output_file:
        return
    with open(output_file, "a") as f:
        for key, value in pairs.items():
            f.write(f"{key}={value}\n")


def output_result(result):
    """Output a single vendor result as key=value lines."""
    print(f"vendor={result['vendor']}")
    print(f"old_version={result['old_version']}")
    print(f"new_version={result['new_version']}")
    print(f"changed={str(result['changed']).lower()}")

    config = load_config()
    vendor_config = config.get("vendors", {}).get(result["vendor"], {})
    install_branch = vendor_config.get("install_branch", f"chore/install-{result['vendor']}")

    write_github_output({
        "vendor": result["vendor"],
        "old_version": result["old_version"],
        "new_version": result["new_version"],
        "changed": str(result["changed"]).lower(),
        "install_branch": install_branch,
    })


def output_results(results):
    """Output results. For single vendor, key=value. For multiple, JSON."""
    changed = [r for r in results if r["changed"]]
    if len(results) == 1:
        output_result(results[0])
    else:
        # For 'all' mode, output JSON array of changed vendors
        print(f"results={json.dumps(changed)}")
        print(f"changed_count={len(changed)}")

        write_github_output({
            "changed_vendors": json.dumps(changed),
            "changed_count": str(len(changed)),
            "changed": str(len(changed) > 0).lower(),
        })


def get_pr_metadata(results):
    """Determine PR branch, title, and body from update results.

    Returns dict with: branch, title, body, automerge.
    Returns None if no vendors changed.
    """
    changed = [r for r in results if r["changed"]]
    if not changed:
        return None

    config = load_config()
    vendors = config.get("vendors", {})

    if len(results) == 1:
        # Single vendor mode
        r = changed[0]
        vendor_config = vendors.get(r["vendor"], {})
        install_branch = vendor_config.get(
            "install_branch", f"chore/install-{r['vendor']}"
        )
        return {
            "branch": f"{install_branch}-v{r['new_version']}",
            "title": f"chore: install {r['vendor']} v{r['new_version']}",
            "body": (
                f"Automated vendor update for **{r['vendor']}**.\n\n"
                f"**Version:** `{r['old_version']}` \u2192 `{r['new_version']}`"
            ),
            "automerge": vendor_config.get("automerge", False),
        }
    else:
        # Multi-vendor mode
        vendor_versions = ", ".join(
            f"{r['vendor']} v{r['new_version']}" for r in changed
        )
        return {
            "branch": "chore/install-vendors",
            "title": f"chore: install {vendor_versions}",
            "body": f"Automated vendor updates.\n\n**Updated:** {vendor_versions}",
            "automerge": False,
        }


def create_pull_request(results):
    """Create a PR with vendor update changes.

    Handles git branch/commit/push, PR creation via gh CLI, and automerge.
    Uses GITHUB_TOKEN for repo operations (not vendor-specific PAT).
    """
    meta = get_pr_metadata(results)
    if meta is None:
        print("No vendor changes to create PR for")
        return

    branch = meta["branch"]
    title = meta["title"]
    body = meta["body"]

    # Environment for gh CLI: prefer GITHUB_TOKEN (repo token) over GH_TOKEN
    # which may be a vendor-specific PAT
    gh_env = os.environ.copy()
    github_token = os.environ.get("GITHUB_TOKEN", "")
    if github_token:
        gh_env["GH_TOKEN"] = github_token

    # Configure git identity
    subprocess.run(
        ["git", "config", "user.name", "github-actions[bot]"],
        check=True, capture_output=True,
    )
    subprocess.run(
        ["git", "config", "user.email",
         "github-actions[bot]@users.noreply.github.com"],
        check=True, capture_output=True,
    )

    # Create branch, stage, commit, push
    subprocess.run(
        ["git", "checkout", "-b", branch],
        check=True, capture_output=True,
    )
    subprocess.run(["git", "add", "-A"], check=True, capture_output=True)

    # Check if there are actual staged changes
    diff_result = subprocess.run(["git", "diff", "--cached", "--quiet"])
    if diff_result.returncode == 0:
        print("No changes to commit")
        return

    subprocess.run(
        ["git", "commit", "-m", title],
        check=True, capture_output=True,
    )
    subprocess.run(
        ["git", "push", "-u", "origin", branch],
        check=True, capture_output=True,
    )

    # Create PR, handle "already exists" gracefully
    pr_result = subprocess.run(
        ["gh", "pr", "create", "--title", title, "--body", body,
         "--head", branch, "--base", "main"],
        capture_output=True, text=True, env=gh_env,
    )

    if pr_result.returncode != 0:
        output = pr_result.stdout + pr_result.stderr
        if "already exists" in output:
            print(f"PR already exists for {branch}")
            return
        print(f"Failed to create PR: {output}")
        sys.exit(1)

    pr_url = pr_result.stdout.strip()
    print(f"Created PR: {pr_url}")

    # Automerge when vendor config has "automerge": true (single vendor only)
    if meta["automerge"]:
        subprocess.run(
            ["gh", "pr", "merge", pr_url, "--auto", "--squash"],
            capture_output=True, env=gh_env,
        )

    return pr_url


def main():
    parser = argparse.ArgumentParser(description="Install or update vendored tools")
    parser.add_argument("vendor", help='Vendor name or "all"')
    parser.add_argument(
        "--version", default="latest",
        help="Version to install (default: latest)"
    )
    parser.add_argument(
        "--pr", action="store_true",
        help="Create a PR with the changes (for CI use)"
    )
    args = parser.parse_args()

    config = load_config()
    vendors = config.get("vendors", {})

    if not vendors:
        print("No vendors configured in .vendored/config.json")
        sys.exit(0)

    if args.vendor == "all":
        results = []
        for name, vcfg in vendors.items():
            results.append(install_vendor(name, vcfg, args.version))
        output_results(results)
    else:
        if args.vendor not in vendors:
            print(f"::error::Unknown vendor: {args.vendor}")
            print(f"Registered vendors: {', '.join(sorted(vendors.keys()))}")
            sys.exit(1)
        result = install_vendor(args.vendor, vendors[args.vendor], args.version)
        output_result(result)
        results = [result]

    if args.pr:
        create_pull_request(results)


if __name__ == "__main__":
    main()
