#!/usr/bin/env python3
"""Add a new vendor to the project.

Pre-validates the target repo, runs its install.sh, and post-validates
that the vendor self-registered in .vendored/config.json.

Usage:
    python3 .vendored/add <owner/repo> [--name <name>]

Environment:
    GH_TOKEN     - Auth token for GitHub API
    GITHUB_TOKEN - Fallback auth token
"""

import argparse
import base64
import json
import os
import subprocess
import sys
import tempfile


CONFIG_PATH = ".vendored/config.json"


def load_config():
    """Load and return the vendored config."""
    if not os.path.isfile(CONFIG_PATH):
        print(f"::error::Config not found: {CONFIG_PATH}")
        sys.exit(1)
    with open(CONFIG_PATH) as f:
        return json.load(f)


def save_config(config):
    """Write config back to disk."""
    with open(CONFIG_PATH, "w") as f:
        json.dump(config, f, indent=2)
        f.write("\n")


def get_auth_token():
    """Get auth token from environment."""
    return os.environ.get("GH_TOKEN", os.environ.get("GITHUB_TOKEN", ""))


def _gh_env(token):
    """Build environment dict with GH_TOKEN set."""
    env = os.environ.copy()
    if token:
        env["GH_TOKEN"] = token
    return env


def check_repo_exists(repo, token):
    """Check that the GitHub repo exists and is accessible."""
    env = _gh_env(token)
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}", "--jq", ".full_name"],
        capture_output=True, text=True, env=env
    )
    if result.returncode != 0:
        print(f"::error::Cannot access repo: {repo}")
        print("Ensure the repo exists and your GH_TOKEN has access.")
        sys.exit(1)


def check_install_sh(repo, token):
    """Verify the repo has an install.sh at its root."""
    env = _gh_env(token)
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/install.sh", "--jq", ".name"],
        capture_output=True, text=True, env=env
    )
    if result.returncode != 0 or not result.stdout.strip():
        print(f"::error::Repo does not implement git-vendored: {repo}")
        print("Expected install.sh at repository root.")
        sys.exit(1)


def resolve_version(repo, token):
    """Resolve the latest version from releases or VERSION file."""
    env = _gh_env(token)

    # Try releases API
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/releases/latest", "--jq", ".tag_name"],
        capture_output=True, text=True, env=env
    )
    if result.returncode == 0 and result.stdout.strip():
        return result.stdout.strip().lstrip("v")

    # Fallback: VERSION file
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/VERSION", "--jq", ".content"],
        capture_output=True, text=True, env=env
    )
    if result.returncode == 0 and result.stdout.strip():
        try:
            content = base64.b64decode(result.stdout.strip()).decode().strip()
            return content
        except Exception:
            pass

    print(f"::error::Cannot resolve version for {repo}")
    print("No GitHub releases found and no VERSION file in repo.")
    sys.exit(1)


def download_and_run_install(repo, version, token):
    """Download install.sh at the given version and execute it."""
    env = _gh_env(token)

    ref = f"v{version}"
    result = subprocess.run(
        ["gh", "api", f"repos/{repo}/contents/install.sh?ref={ref}",
         "--jq", ".content"],
        capture_output=True, text=True, env=env
    )

    if result.returncode != 0 or not result.stdout.strip():
        # Try without v prefix
        result = subprocess.run(
            ["gh", "api", f"repos/{repo}/contents/install.sh?ref={version}",
             "--jq", ".content"],
            capture_output=True, text=True, env=env
        )

    if result.returncode != 0 or not result.stdout.strip():
        print(f"::error::Failed to download install.sh from {repo} at {ref}")
        sys.exit(1)

    install_script = base64.b64decode(result.stdout.strip()).decode()

    with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
        f.write(install_script)
        temp_path = f.name

    try:
        run_env = env.copy()
        run_result = subprocess.run(
            ["bash", temp_path, version],
            capture_output=True, text=True, env=run_env
        )
        if run_result.stdout:
            print(run_result.stdout, end="")
        if run_result.stderr:
            print(run_result.stderr, end="", file=sys.stderr)
        if run_result.returncode != 0:
            print(f"::error::install.sh failed for {repo} (exit {run_result.returncode})")
            sys.exit(1)
    finally:
        os.unlink(temp_path)


def find_new_entry(before_vendors, after_vendors):
    """Find the vendor key that was added between before and after configs."""
    before_keys = set(before_vendors.keys())
    after_keys = set(after_vendors.keys())
    new_keys = after_keys - before_keys
    if not new_keys:
        return None, None
    # Return the first new key (typically there's just one)
    key = next(iter(new_keys))
    return key, after_vendors[key]


def validate_entry(vendor_name, entry):
    """Validate that a new vendor entry has all required fields."""
    required = ["repo", "protected", "install_branch"]
    missing = [f for f in required if f not in entry]
    if missing:
        print(f"::error::Vendor '{vendor_name}' missing required fields: {', '.join(missing)}")
        print("install.sh must self-register with: repo, protected, install_branch")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="Add a new vendor to the project"
    )
    parser.add_argument("repo", help="GitHub repo (owner/name)")
    parser.add_argument(
        "--name", default=None,
        help="Override the vendor key name (default: repo name)"
    )
    args = parser.parse_args()

    repo = args.repo
    vendor_name = args.name

    token = get_auth_token()

    # Pre-validate
    check_repo_exists(repo, token)
    check_install_sh(repo, token)
    version = resolve_version(repo, token)

    # Check not already registered
    config = load_config()
    vendors = config.get("vendors", {})

    # Determine the expected key
    if vendor_name:
        if vendor_name in vendors:
            print(f"::error::Vendor '{vendor_name}' is already registered.")
            print("Use vendored/update to update existing vendors.")
            sys.exit(1)
    else:
        # Check by repo match
        for name, vcfg in vendors.items():
            if vcfg.get("repo") == repo:
                print(f"::error::Vendor '{name}' already registered for {repo}.")
                print("Use vendored/update to update existing vendors.")
                sys.exit(1)

    # Snapshot config before
    before_vendors = dict(vendors)

    # Run install.sh
    print(f"Adding {repo} v{version}...")
    download_and_run_install(repo, version, token)

    # Post-validate: reload config and find new entry
    after_config = load_config()
    after_vendors = after_config.get("vendors", {})

    new_key, new_entry = find_new_entry(before_vendors, after_vendors)

    if new_key is None:
        print("::error::install.sh did not register a vendor in config.")
        print("install.sh must self-register by adding an entry to .vendored/config.json")
        sys.exit(1)

    validate_entry(new_key, new_entry)

    # Output summary
    print(f"\nAdded vendor: {new_key}")
    print(f"  repo: {new_entry['repo']}")
    print(f"  version: {version}")
    print(f"  protected: {', '.join(new_entry.get('protected', []))}")
    if new_entry.get("allowed"):
        print(f"  allowed: {', '.join(new_entry['allowed'])}")


if __name__ == "__main__":
    main()
