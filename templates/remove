#!/usr/bin/env python3
"""Vendor removal command.

Removes a vendored tool by deleting its files and config entry.

If a manifest exists at .vendored/manifests/<vendor>.files, uses exact file
paths for clean removal. Without a manifest, uses config 'protected' patterns
to find files to remove (interactive confirmation required).

Usage:
    python3 .vendored/remove <vendor> [--force]

Options:
    --force     Skip confirmation prompt (for CI use)
"""

import argparse
import fnmatch
import json
import os
import sys


CONFIG_PATH = ".vendored/config.json"
MANIFESTS_DIR = ".vendored/manifests"


def load_config(config_path=CONFIG_PATH):
    """Load and return the vendored config."""
    if not os.path.isfile(config_path):
        print(f"::error::Config not found: {config_path}")
        sys.exit(1)
    with open(config_path) as f:
        return json.load(f)


def save_config(config):
    """Write config back to disk."""
    with open(CONFIG_PATH, "w") as f:
        json.dump(config, f, indent=2)
        f.write("\n")


def read_manifest(vendor_name):
    """Read a vendor's manifest file. Returns list of paths, or None if missing."""
    manifest_path = os.path.join(MANIFESTS_DIR, f"{vendor_name}.files")
    if not os.path.isfile(manifest_path):
        return None
    with open(manifest_path) as f:
        return [line.strip() for line in f if line.strip()]


def find_files_by_patterns(patterns):
    """Walk the filesystem and find files matching any of the glob patterns.

    Used as a fallback when no manifest exists.
    """
    matches = []
    for root, dirs, files in os.walk("."):
        for filename in files:
            filepath = os.path.join(root, filename)
            # Normalize path: strip leading ./
            if filepath.startswith("./"):
                filepath = filepath[2:]
            for pattern in patterns:
                if fnmatch.fnmatch(filepath, pattern):
                    matches.append(filepath)
                    break
                # Handle ** patterns
                if "**" in pattern:
                    prefix = pattern.split("**")[0]
                    if filepath.startswith(prefix):
                        matches.append(filepath)
                        break
    return sorted(matches)


def get_files_to_remove(vendor_name, vendor_config):
    """Determine which files to remove for a vendor.

    Returns (files, source) where source is 'manifest' or 'patterns'.
    """
    manifest_files = read_manifest(vendor_name)
    if manifest_files is not None:
        # Also include the manifest files themselves
        extra = [
            os.path.join(MANIFESTS_DIR, f"{vendor_name}.files"),
            os.path.join(MANIFESTS_DIR, f"{vendor_name}.version"),
        ]
        all_files = manifest_files + [f for f in extra if os.path.isfile(f)]
        return all_files, "manifest"

    # Fallback: scan filesystem using protected patterns
    patterns = vendor_config.get("protected", [])
    allowed = vendor_config.get("allowed", [])
    if not patterns:
        return [], "patterns"

    # Find all files matching protected patterns, excluding allowed
    found = find_files_by_patterns(patterns)
    # Exclude allowed files
    files = []
    for f in found:
        is_allowed = False
        for pattern in allowed:
            if fnmatch.fnmatch(f, pattern):
                is_allowed = True
                break
            if "**" in pattern:
                prefix = pattern.split("**")[0]
                if f.startswith(prefix):
                    is_allowed = True
                    break
        if not is_allowed:
            files.append(f)
    return files, "patterns"


def remove_files(files):
    """Delete the given files from disk. Returns count of files removed."""
    removed = 0
    for filepath in files:
        if os.path.isfile(filepath):
            os.remove(filepath)
            removed += 1
    return removed


def cleanup_empty_dirs(files):
    """Remove empty parent directories after file deletion."""
    dirs = set()
    for filepath in files:
        parent = os.path.dirname(filepath)
        while parent and parent != ".":
            dirs.add(parent)
            parent = os.path.dirname(parent)

    # Sort deepest first so we can prune bottom-up
    for d in sorted(dirs, key=lambda x: x.count("/"), reverse=True):
        if os.path.isdir(d) and not os.listdir(d):
            os.rmdir(d)


def main():
    parser = argparse.ArgumentParser(
        description="Remove a vendored tool"
    )
    parser.add_argument("vendor", help="Vendor name to remove")
    parser.add_argument(
        "--force", action="store_true",
        help="Skip confirmation prompt"
    )
    args = parser.parse_args()

    config = load_config()
    vendors = config.get("vendors", {})

    if args.vendor not in vendors:
        print(f"::error::Unknown vendor: {args.vendor}")
        print(f"Registered vendors: {', '.join(sorted(vendors.keys()))}")
        sys.exit(1)

    vendor_config = vendors[args.vendor]
    files, source = get_files_to_remove(args.vendor, vendor_config)

    if not files:
        print(f"No files found for vendor '{args.vendor}'")
        # Still remove the config entry
        del vendors[args.vendor]
        config["vendors"] = vendors
        save_config(config)
        print(f"Removed '{args.vendor}' from config.")
        return

    print(f"Files to remove for '{args.vendor}' ({source}):")
    for f in files:
        exists = os.path.isfile(f)
        print(f"  {'  ' if exists else '? '}{f}")

    if not args.force:
        try:
            answer = input(f"\nRemove {len(files)} files and unregister '{args.vendor}'? [y/N] ")
        except EOFError:
            answer = ""
        if answer.lower() not in ("y", "yes"):
            print("Aborted.")
            sys.exit(0)

    removed = remove_files(files)
    cleanup_empty_dirs(files)

    # Remove config entry
    del vendors[args.vendor]
    config["vendors"] = vendors
    save_config(config)

    print(f"\nRemoved {removed} files and unregistered '{args.vendor}'.")


if __name__ == "__main__":
    main()
